一.定义
1》什么是JavaScript
	a."弱类型"的脚本语言
	b.基于"原型"的脚本语言

2》js可以干什么
	a.主要用于web页面使用
	b.被非浏览器环境去使用（nodejs）

3》js的构成
	ECMScript：核心语法，基本对象
	DOM:文档对象模型
	BOM:浏览器对象模型

4》在html如何使用js
	a.本页面写入：
	<script type="text/javascript"></script>
	b.外部引入：
	<script type="text/javascript" src=""></script>
	****引入位置:</body>前

5》js的输出语句  (用于程序员自己去调试代码的时候用的)
	document.write() ===>在文档中打印内容
	console.log() ===>在控制台打印内容

	注意:这句话写完以后用；作为结尾
 

二.延迟和异步加载js
1》如何延迟加载js:defer
	<script type="text/javascript" defer src="路径"></script>
	defer:js脚本可以延迟到文档完全被解析和显示之后执行

2》如何异步加载js
 	<script type="text/javascript"  async src="路径"></script>
 	async:立即执行脚本，但不妨碍页面其他的操作
 	****简单粗暴：谁先加载完了谁执行

三.变量和注释
1》js中的变量
	命名规则：1.首位：字母、_、$
	2.严格区分大小写
	3.采用驼峰命名（第二个单词开始之后每一个单词首字母大写）
	声明变量：var
	-----变量名禁止使用关键字-----

2》js中的注释
	单行：//
	多行：/**/

企业级注释：1.公共的js文件
		   /**
		   *文件用途说明
		   *作者姓名，联系方式
		   *制作日期
		   **/
		   2.大的模块注释方法
		   //====================
		   //代码用途
		   //====================


四.数据类型
1》基本数据类型（原始）
	string：字符串 ===>基本上加入引号的都是字符串类型
	number：数值 ===>计算
	boolean：布尔 ===>判断，有两个值，true、false
	undefined：表示缺少值，应该是有一个值，但是还没有赋值
	null:表示没有对象，即该处不应该有值 ***特殊的object

=============undefined和null区别=================

null表示无对象，把它转换成数值是0
undefined表示缺少值，把它转换成数值是NaN

=================================================
2》引用数据类型 【array,function】
	object

-------------typeof 检测数据模型----------------

五.企业级规范
1.引号 引号的使用，单引号' '优先（如果不是引号嵌套，不要使用双引号）
2.变量命名
	a.str,num,bol,obj,fun,arr:作用域不大的情况
	b.循环 i,j,k
	c.变量命名前缀： 数组：a
					字符串：s
					数值：n
					逻辑：b
					函数：f
					对象：o
					正则：r

六.数据类型的转换

1》其他类型转换成 ==> 字符串类型
	a.数据.toString()
	b.String(数据)

2》其他类型转换成 ==> 数值类型
	a.Number（数据）
	b.parseInt(数据)   ==>整数
	c.parseFloat(数据) ==>小数
**注意：布尔true:1,布尔false:0
		字符串不是纯数字:NaN
**NaN:属性，代表非数字值的特殊值（数值类型）

3》其他类型转换成 ==> 布尔类型
	a.数值：
		0--false
		NaN--false
		其他--true
	b.字符串：
		非空字符串--true，空字符串--false
	c.其他：
		null--false
		undefined--false


七.变量存储机制原理 

1》内存

2》内存生命周期（三个周期）
	分配期：分配所需要的内存
	使用期：读、写
	释放期：不需要时将其释放
内存分配===>内存使用===>内存释放

3》javascript内存生命周期
	内存分配：分配你所需要的暂时使用的内存大小
	内存使用：读、写内存
	内存回收：对于不需要使用的内存将其释放

4》栈内存、堆内存
	栈内存：
		1.基本类型(string,number,boolean,undefined,null)
		2.按值访问
		3.存储的值大小固定
		4.系统会自动分配内存空间
		5.空间小，运行效率高
		6.先进后出
	推内存：
		1.引用类型（object）
		2.按引用访问
		3.存储大小不固定
		4.由代码进行指定分配
		5.空间大，运行效率低
		6.无序存储（根据引用直接获取）

八.运算符
8.1 算术运算符：
	+ - * / %(求余)
数据类型隐式转换的问题：
	a》布尔和数字或者纯布尔相加(+)，布尔会自动转换成数值类型
	b》字符串和任何类型(+)，其他类型都会转换成字符串
***注意：除了加以外，其他的都是按照数值进行运算

8.2 赋值运算符：
	=  连续赋值：var a=b=c=d=100; 
		区别：var a  局部  ；  b,c,d  全局
	+=  x=x+y
	-=  x=x-y
	*=  x=x*y
	/=  x=x/y
	%=  x=x%y
***注意：var a 是局部变量（在全局范围内是全局的）；b  window.b  全局
===补充：在js中尽量不要写全局变量

8.3 比较运算符：
	==   :等于
	===  :值相等并且类型相等
	!=   :不相等
	!==  :值不相等并且类型不相等
	> , < , >= ,  <=   
***返回的结果是布尔类型：true,false

8.4 一元运算符：
	i++
	++i

	i--
	--i

规则：如果不参与运算，++在前面和后面结果是一样的
如果有运算，++在前面(++i),则表示：先自身+1，再运算
如果有运算，++在后面(i++),则表示：先运算，再自身+1


8.5 二元运算符：
	&&(与):
		1.语法格式：表达式 && 表达式
		2.规则：如果（左边表达式）判断是false，则返回（左边表达式）的值，否则返回（右边表达式）的值
	||(或):
		1.语法格式：表达式 || 表达式
		2.规则：如果（左边表达式）判断是true，则返回（左边表达式）的值，否则返回（右边表达式）的值
	!(非):取反 做逻辑运算


8.6 三元运算符：
	语法格式：条件？ 结果1：结果2
	如果条件成立true，执行结果1，否则执行结果2

九 流程控制语句-if
	语法格式：
		if(条件){
			条件成立时，执行这里代码
		}else{
			条件不成立时，执行这里代码
		}
	多条件：
		if(条件1){
			如果条件1成立时，执行这里代码
		}else if(条件2){
			如果条件2成立时，执行这里代码
		}else if(条件3){
			如果条件3成立时，执行这里代码
		}....
		else{
			如果以上条件都不满足，执行这里代码
		}


十 if的嵌套
	语法格式：
		if(条件){
			条件成立时，执行这里代码
			if(条件){
				条件成立时，执行这里代码
			}else{
				条件不成立时，执行这里代码
			}
		}else{
			条件不成立时，执行这里代码
			if(条件){
				条件成立时，执行这里代码
			}else{
				条件不成立时，执行这里代码
			}
		}
****补充知识：
	1.弹出输入框：prompt
	2.isNaN():检查参数是否是非数字值
		如果是字符串，对象...，返回结果是true
		如果是数值返回结果是false

十一 流程控制语句-switch
	语法格式：
		swtich(表达式){
			case值：
				执行这里代码
			break;
			case值：
				执行这里代码
			break;
			case值：
				执行这里代码
			break;
			default:
				执行这里代码
		}
*****
1.if 和 switch 运行效率来看，switch要快一点
2.if语句可以多个条件表达式，switch只能一个条件表达式

十二 循环语句-for
	循环的解释：在有限的条件下，反复不断地执行某种事情
	for循环语法格式：
		for(起始条件;终止条件;步长值){
			循环体
		}

十三 for循环语句的嵌套
	for(起始条件;终止条件;步长值){
		循环体
		for(起始条件;终止条件;步长值){
			循环体
		}
	}

十四 跳出语句
	break:跳出当前循环
	continue：跳出当前循环，但是继续执行当前循环
	return(函数)

十五 while和do...while循环
1.while
	语法格式：
	while(条件|终止条件){
		循环体
		步长值
	}
	for：可以在很明确循环次数上做内容
	while：不明确循环次数，也可以做

2.do...while
	语法格式：
	do{
		循环体;
		步长值;
	}while(条件|终止条件);

*****函数*****
十六 函数定义-函数调用
做成不同的模块，好处：复用性，封装性（模块）
1.函数的定义
	函数声明
		语法格式:
		function 函数名(){
			函数体
		}
	函数表达式
		语法格式:
		var 变量名 = function 函数名(){
		}
==========区别：
	a.函数表达式：函数只能在声明之后调用，因为这种方式的函数，是在函数运行的阶段赋值给变量的
	b.函数声明：函数可以在声明函数的“作用域”任意范围内调用，因为这种方式，是在函数解析阶段赋值给函数名
	
2.函数的调用【使用】
	函数表达式或者函数声明是不能自己执行的，需要调用才可以执行
	调用：函数名();
==========补充：
	a.函数如果没有调用，则不会保存在内存中
	b.当函数调用完毕，其中函数的代码就会被系统内存回收


十七 函数的参数-arguments-return
1.函数的参数
	function fun(形参1，形参2，形参3...){
	}
	fun(实参1，实参2，实参3...);
	形参：虚构存在的===>名
	实参：实际存在的===>实际的值
2.arguments对象
	作用：就是操作实参
	arguments.length   就是实参的长度 【个数】
	arguments[0]    就是实参的第一个
3.return
	返回 ==> 跳出当前函数体

==========补充：
	1.length：长度 【个数】

十八 匿名函数
1.匿名函数：没有名字的函数
	function(){
	}   //由于不符合语法要求，所以会报错
	解决：
	(function(){
	})
2.匿名函数的自我执行
	语法格式：
	(function(形参1,形参2...){
	})(实参1,实参2...)


十九 js执行环境
1.什么是执行环境
	执行环境又称执行上下文
	执行环境定义了变量或者函数有权或无权访问其他数据，决定了各自的行为

2.执行环境分类（3大类）
	1》全局执行环境：是最外围的执行环境
	在页面中，全局执行环境是window对象
*当一打开页面，会自动生成window对象，那么全局的变量或者函数都属于window对象的内容。那么window就是全局的。
	2》函数执行环境
	当某个函数被调用时，首先会创建一个执行环境以及作用域链，然后使用arguments和其他的参数来初始化这个执行环境。

=========回收机制：
	某个执行环境中的所有代码执行完毕，保存在执行环境中的变量或者函数都会进行销毁（回收）
	但是全局执行环境是到关闭浏览器或者当前页面才会被回收

3.执行环境的生命周期
	1》创建阶段-----生成变量对象，建立作用域链，确定this指向
	2》执行阶段-----变量赋值，赋值调用，执行其他代码
	3》销毁回收阶段


二十 BOM
1.BOM：浏览器对象模型：围绕“浏览器”的一些操作
	BOM可以做的事情：
	1.获取到浏览器的型号（手机的型号）
	2.url操作
	3.屏幕的大小尺寸

2.location对象：操作浏览器当前url
	href   :本身是可以获取到当前的url  ，  设置对应跳转的url

		**location.href='xxx'可以跳转到对应的页面
		但是是在本页面进行的跳转，不是新窗口打开，怎么办？

		window.open(url,'_blank'):新窗口打开

	search :设置或者获取，从问号（?）开始的url
	hash   :设置或者获取，从井号（#）开始的url

解码：decodeURIComponent

3.history:操作浏览器窗口访问过的url
	back：返回上一页
	forward：前进下一页
	go：前往指定的页面
	go(-1)==back：返回上一页   go(1)==forward：前进下一页   go(0)：刷新

4.navigator:包含有关浏览器的信息
	userAgent:用户代理头的值
	platform:返回运行浏览器的操作系统

5.screen:客户端屏幕信息
width:返回显示屏幕的宽度
height:返回显示屏幕的高度


二十一 定时器
1》setInterval:间歇调用,"后",定时任务处理的函数添加到执行队列到队尾
	语法格式：
		setInterval( 执行匿名函数,毫秒数 )

2》setTimeout:超时调用,"后",定时任务处理的函数添加到执行队列到队尾
	语法格式：
		setTimeout( 执行匿名函数,毫秒数 )

3》清除定时器
	clearInterval ===>setInterval
	clearTimeout  ===>setTimeout
	语法格式：
		clearInterval(清除哪一个定时器)
		clearTimeout(清除哪一个定时器)

二十二 js的单线程
1.js语言是一个单线程
	同一时间只能做一件事情，这也就意味着所有的任务需要排队，前一个任务执行结束了，才可以继续执行下一个任务。
2.js语言为什么是单线程============用户体验
	取决于js用在什么地方？和用户相关

***************
事件队列（定时器，ajax....）:先进先出


二十三 图片轮播

1.获取某个id元素：document.getElementById('id值');
2.获取集合元素：document.getElementsByTagName('元素名称');
3.获取集合元素的个数：length
4.给一个元素添加样式：main.style.background='blue';


二十四 数组
1.什么是数组
	使用单独的变量名来存储“一系列”的值
2.数组可以做什么事
	存储一系列（大量）的值
3.使用数组
a.如何创建数组

	构造函数形式
		语法格式:new Arrary('字符串',数值：12,布尔：true)
	***如果只有一个参数，这个参数就是数组的长度（只限数值）

	字面量***
		语法格式:['字符串',数值：12,布尔：true]

b.数组属性：长度length

**********
数组是一个对象

二十五 今天玩什么游戏
	
二十六 多维数组
	二维：[  []  ]
	三维：[  [  []  ]  ]

二十七 数组-数组方法
1.concat():合并数组，最后返回一个新的数组

2.reverse():反转数组项的顺序
***会改变原来的数组

3.join(参数分隔符):将数组的元素组成一个字符串，用参数分隔符进行分割，默认以逗号分隔
***把数组转换成字符串

	语法格式：
		数组.方法名称(参数)
4.push():将参数添加到原数组的末尾，并且返回数组的长度
  pop():数组末尾移除最后一项，返回移除的项
5.unshift:将参数添加到原数组的开头，并且返回数组的长度
  shift():删除数组第一项，返回移除的项
6.slice(参数1，参数2):截取，返回新的数组
	参数1：开始位置    参数2：结束位置
	***1个参数（正数）：丛当前下标（包括下标）开始往后截取
	***2个参数（正数）：从参数1（包括参数1）开始到参数2（不包括参数2）
7.sort():排列数组项
	sort(function(a,b){
		return a-b;  //从小到大
		return b-a;  //从大到小
	})
8.indexOf(参数):查找，查找参数在数组中是否存在，如果存在返回下标，如果不存在返回-1
9.splice():可以实现删除，插入，替换操作
	删除：2个参数(1,2) 从下标1开始，删除2个
	替换：3个参数(0,1,4) 从下标0开始，长度为1到数组元素替换成4
	插入：3个参数(1,0,5)表示在下标为1处添加一项5

二十八 数组-循环遍历数组方法
1.forEach
	语法格式：
		数组.forEach(function(item,index){
			item  ==> 数组的每一项
			index ==> 数组的下标
		})
	缺点：不可以使用break和return
2.map: 里面支持return，并且返回新的数组
3.filter:过滤，并且返回新的数组
------------------返回布尔值------------------------
4.every:所有的为true，则返回true
5.some:只要有一项为true，则最终返回true

二十九 冒泡排序

三十 数组去重

三十一 字符串
1.字面量：var str='你好';
2.构造函数：var str=new String('你好');
----------区别---------
字面量形式存储在栈内存，构造函数形式存储在堆内存
	typeof  字面量  ==>string
	typeof  构造函数==>object
========为什么字面量的string，boolean，number也有属性和方方法
string，boolean，number:原始的资料类型	
 new String，new Boolean，new Number:包装对象


************JS：一切事物皆对象*************
对象拥有属性和方法
3.字符串方法
	1》 charAt(数值): 返回指定“位置”的字符
	2》 indexOf(字符): 查找，有返回下标，没有返回-1
	3》 replace(把什么替换成什么):替换
		默认只替换一次，如果要全部替换，str.replace(/大爷/g,'***')
	4》trim():去除前后空格
	5》toLowerCase():把字符转换成小写
	6》toUpperCase():把字符转换成大写
	7》split():把字符串转换成数组

------------把数组转换成字符串：join()  ,  把字符串转换成数组：split()
------------字符串截取
	slice(start,end)
	substring(start,end): 负数转换成0
	substr(start,length): length为长度

三十二 上传文件判断后缀名
	上传头像，图片 ==> .png .jpg .jpeg

三十三 手机号中4位隐藏

三十四 数学对象
Math.max()  取一组数的最大值
Math.min()  取一组数的最小值
Math.round() 四舍五入
Math.abs() 返回数的绝对值 
Math.sqrt() 返回数的平方根
Math.floor() 向下取整
Math.ceil()  向上取整
Math.random() 返回随机数，0~1，包括0，不包括1 
	随机的公式：
	1》不包含最大值，包含最小值
	Math.floor(Math.random()*(max - min)+min);
	2》包含最大值，包含最小值
	Math.floor(Math.random()*(max - min+1)+min);


三十五 生成随机验证码
防止暴力破解

三十六 日期对象：new Date()
日期对象的方法：
		1.对象.getFullYear()  --年
		2.对象.getMonth()     --月(0-11)
		3.对象.getDate()      --日
		4.对象.getHours()     --时
		5.对象.getMinutes()   --分
		6.对象.getSeconds()   --秒

*******时间戳：从1970年1月1日至今的时间（毫秒）
	对象.getTime()   返回时间戳

三十七 京东秒杀

三十八 DOM (document object model)

1.DOM：文档对象模型
******在js看来，文档是对象

2.获取文档节点[元素]的方法 
	获取id:document.getElementById('main');
	获取标签名：document.getElementsByTagName('li');        -----获取到的是集合元素:有length有下标
	获取class名：document.getElementsByClassName('class名');-----获取到的是集合元素:有length有下标
	通过选择器来获取一个节点：document.querySelector();
	通过选择器来获取所有节点：document.querySelectorAll();    -----获取到的是集合元素:有length有下标
	选择器：class选择器  id:#  class:.  标签名

3.节点属性
<div></div> :节点
	1》innerHTML,innerText:给节点添加内容的
		innerText 解析不了html标签
	2》nodeName: 返回节点名称   ****返回大写字母(DIV)
		用途：一般用来做判断使用
	3》firstElementChild:获取到第一个子元素节点
	4》lastElementChild :获取到最后一个子元素节点 
	5》parentNode:获取到父节点
	6》className:获取或者设置节点的class

4.节点方法-操作节点属性
<div id="main" class="container"></div>
	1》获取
		节点对象.getAttribute('属性名称'): 返回对应属性名称的值
	2》设置
		节点对象.getAttribute('属性名称','对应的值')
	3》删除
		节点对象.removeAttribute('属性名称')
***********注意规范***********
如果要自定义属性名称：data-xxx,例如data-title

三十九 节点创建-添加-删除
1.创建节点
	document.createElement('节点名称');
2.添加节点
	追加：父节点.appendChild(子节点)
	前置：父节点.insertBefore(添加的子节点,添加到谁前面)
3.删除节点
	父节点.removeChild(子节点:删除谁)

**********javascript:; =====>禁止href跳转到功能


四十 案例 增删操作

四十一 节点大小-节点位置
1.获取样式表中的样式
	语法格式：
		getComputedStyle(节点,null).样式名称
2.获取元素的大小和偏移位置
	大小：
		节点对象.offseWidth
		节点对象.offseHeight
	******计算：width+padding+boeder   ==没有px单位,返回的是数值类型

	大小：
		节点对象.clientWidth
		节点对象.clientHeight
	******计算：width+padding  ==没有px单位,返回的是数值类型

	偏移：距离
		节点对象.offseLeft(从左到右) 
		节点对象.offseTop (从上到下) 
	==如果没有定位，相对整个文档偏移；如果有定位，相对父节点偏移
3.滚动距离
	节点对象.scrollLeft
	节点对象.scrollTop

四十二 事件-事件流
1.什么是事件 （事件的起因）
	被Javascript侦测到的行为
2.都有哪些事件
	即鼠标点击，页面或图像载入，鼠标悬浮于页面的某一个热点之上，在表单中选取输入框，确认表单，键盘按键等操作
3.事件在什么时候执行
	时间通常与函数配合使用，当事件发生时函数才会执行
4.事件流
	事件执行的顺序
	历史原因：
	早期的IE事件传播方向为由上至下，即从document逐级向下传播到目标元素;
	而Netscape公司则是朝相反的方向传播，也就是从目标元素开始向上逐级传播最终至window。两家公司对于事件 流出现了截然相反的定义。
	后来ECMAScript在DOM2中对事件流进行了进一步规范，基本上就是上述二者的结合。
	当事件发生时，最先得到通知的是window,然后是document,由上至下逐级依次而入，直到真正触发事件的那个元素(目标元素)为止，这个过程就是捕获。
	接下来，事件会从目标元素开始起泡，由下至上逐级依次传播，直到window对象为止，这个过程就是冒泡。所以捕获比冒泡先执行。
5.事件流分为两种：
	1》事件捕获：是从window开始向下传播，一直到目标节点
	2》事件冒泡：是从目标节点开始向上传播，一直到window

四十三 鼠标类事件
onclick       单击事件
ondblclick    双击事件
oncontextmenu 右击事件
onmousedown   鼠标按下         -在拖拽的时候会用到
onmouseup     鼠标释放(松开)   -在拖拽的时候会用到
onmouseover   鼠标经过
onmouseout    鼠标离开
onmousemove   鼠标悬浮         -在放大镜效果会用到

四十四 键盘类事件
onkeydown     键盘按下         
onkeyup       键盘释放(松开)     
********可以通过keyCode获得键值：e.keyCode

四十五 其他类事件
onload:加载完毕后立即执行的操作
	1.window.onload ===>网页加载完毕后
	2.判断图片是否加载完成了  45-1
onfocus   :获取焦点
onblur    :失去焦点
onscroll  :滚动条事件
onchange  :内容改变时触发 ====select使用  45-3

四十六 事件处理程序-添加
1.HTML事件处理程序：把事件直接写在节点上
	缺点：代码耦合
2.DOM 0级事件处理程序：main.onclick=function(){}
	同样元素的同样事件会被覆盖
3.DOM 2级事件处理程序：dom对象.addEventListener(事件名称，函数，false|true)
	注意：事件名称：不需要加入on，false:冒泡，true：捕获
	缺点：在IE8或者以下不兼容
4.IE事件处理程序：dom对象.attachEvent(事件名称，函数)
	注意：事件名称：需要加入on

四十七 事件处理程序-删除
onmouseup=function(){
	删除onmousemove事件
}
1.DOM 0级删除事件：dom对象.事件名称=null
2.DOM 2级删除事件：dom对象.removeEventListener(事件名称，函数，false|true)
3.IE 删除事件：dom对象.detachEvent(事件名称，函数)

四十八 事件对象-事件委托
1.事件对象:e
	main.onclick=function(e){
		console.log(e);
	}
2.事件对象的属性
	事件对象e.target:目标==》返回对应的dom对象
	clientX:当前鼠标的位置距离浏览器左侧的距离  48-3
	clientY:当前鼠标的位置距离浏览器顶部的距离
3.事件委托===特别重要   48-1  48-2
	2.即使后添加的内容也有效

四十九 阻止冒泡-阻止默认行为
事件流：冒泡，捕获
1.阻止冒泡
	事件对象.stopPropagation()
2.阻止默认行为
	事件对象.preventDefault()

五十 案例：拖拽效果
	有哪些事件？
	1.鼠标按下：onmousedown
	2.鼠标移动：onmouseover || onmousemove
	3.鼠标释放：onmouseup

五十一 案例：放大镜
	小：400*400
	阴影--->可以移动（定位）
	大：800*800 
	图片（定位,left,top）

五十二 案例：小米购物车

五十三  案列：商品规格筛选

五十四 案例：tab切换

五十五 案例；菜单tab切换

五十六 正则表达式
1.什么是正则表达式：规则表达式 
2.应用场景：表单的验证
3.正则的使用
	定义：字面量//  构造函数：new RegExp()
	区别：new RegExp():放入变量
4.正则的方法
	test():检测一个内容是否与正则匹配，如果匹配返回true，不匹配返回false
	exec():检测一个内容是否与正则匹配，如果匹配返回数组，不匹配返回null

五十七 正则-元字符-转义
1.元字符
	[] 匹配中括号内任意一个字符  *验证手机号：11位
	[^] 除了中括号内任意字符
	[0-9] 匹配数字0-9范围   *可以修改范围[3-9]
	[a-z] [A-Z] 匹配字母
	\d 匹配数字
	\D 匹配非数字
	\w 匹配数字，字母，下划线 ===>[a-zA-Z0-9_]
	\W 匹配非数字，字母，下划线
	\s 匹配空格
	\S 匹配非空格
	\b 匹配边界
	\B 匹配非边界
	. 匹配除了换行符以外的任意字符
2.转义(\)--本身失去原有的功能/\./

五十八 正则-选择符-修饰符
1.选择符
	| 或
2.修饰符
	i: 不区分大小写
	g: 全文匹配
	m:（不常用）
3.字符串方法可以配合正则去用
	replace
	match(类似于exec):  --matc支持全局，查找返回对应的值[值是数组]，没有找到返回null

五十九 正则-限定符-重复
1.限定符
	^  开始
	$  结束
	验证手机号：11位的数字
2.重复 
	{n}   重复n次
	{n,}  重复最少n次，最多不限
	{n,m} 重复最少n次，最多m次
	*     重复最少0次，最多不限
	+     重复最少1次，最多不限
	？    重复最少0次，最多1次

************补充事件：oninput

六十 正则-贪婪模式-懒惰模式
1.贪婪模式
	/\d{3,6}/g;
2.懒惰模式
	/\d{3,6}?/g;

六十一 正则-分组-字符类
1.分组：
	():把部分内容组合在一起
2.字符类： 来获取分组内的内容的
	$1
	$2
	$3
******前提：正则必须执行一次

六十二 前瞻
前瞻和后顾(js正则没有后顾)
1.正向前瞻：(?=):匹配符合的
2.负向前瞻：(?!):匹配不符合的

六十三 案例：验证表单

六十四 案例：手机号钝点

六十五 面试题：判断一个字符串出现次数最多的字符，并统计次数
var s='aaabbbcccaaabbbaaabbbbbbbbbb'

六十六 验证文件后缀名

六十七 电子邮箱

六十八 作用域-作用域链
1.作用域(作用的区域或者作用的):
	全局作用域，全局就是window
	在全局作用域下写的变量：没有区别，都属于window对象属性
	var str1='123'; 
	window.str2='123';
	str3='123';
	在局部作用域下写变量
	var str1='123';   =====》声明局部变量
	window.str2='123';=====》声明全局变量
	str3='123';       =====》声明全局变量
2.作用域链:从内部向外,链(从当前作用开始找，如果找不到向外作用域找，找到返回)

六十九 悬挂变量声明【变量提升】
	js提升所有变量声明，将他们移到其作用域的开头

七十 优先级-作用域面试题  
1.顺序，优先级
	变量 > 函数 > 参数 > 变量提升

七十一 严格模式:'use strict'
1.使用方式
	a.针对于整个文件[全局]：文件的开头(第一行)写入'use strict'
	b.针对于单个函数[局部]：函数内开头(第一行)写入'use strict'
2.作用
	a.变量声明的问题：var|window       -如果写法是：str=123;就报错
	b.禁止this关键字指向全局对象
	c.重名问题，函数不能有重名的参数
	d.arguments对象不能赋值

七十二 递归函数:自己调用自己
注意：必须有结束条件，如果没有结束条件就变成死循环
功能：
	1+2+3+4..+100
	数组扁平化：把多维数组变成一维数组    72-1

七十三 DOM树递归操作

七十四 斐波那契算法递归操作
1.有一对兔子，从出生的第三个月起每个月会生一对兔子，小兔子长到第三个月后每个月也会生一对兔子，
假如兔子不死，那么第N个月有多少对兔子?
产量分析:1 1 2 3 5 8 13 21...
2.走楼梯:一共10级楼梯，每次可以走一步或者可以走二步，求一共多少走法。  74-1

七十五 闭包
1.块级作用域(js没有块级作用域)
	{}
	function fun(){   ==js中函数是有作用域

	}
2.作用域和作用域链---从内逐级向外查找
	a.当函数声明的时候，函数会通过内部属性，scope来记录创建范围
3.闭包
	a.什么是闭包：
		闭包是一个函数加上到创建函数的作用域的链接，闭包就是‘关闭’了函数的自由变量
		-有2个函数，作用域是连接关系[scope]
		--变量不自由，会停留在内存中，不会销毁
	b.闭包可以做什么事：无意间共享环境    75-1

七十六 瀑布流-页面布局

七十七 undefined和null区别-instanceof
1.回顾数据类型
	原始数据类型（基本数据类型）
		字符串，数值，布尔，undefined，null
	引用类型 
		对象：object 
===基本和引用区别：
	每个对象都有唯一的标识，并且严格的等于自身。
===undefined和null区别
	undefined:未定义     null:没有对象
	先设计的null,后设计的undefined
	JavaScript的最初版本是这样区分的:null是一个表示"无"的对象(空对象指针)，转为数值时为0;
undefined是一个表示"无"的原始值，转为数值时为NaN。
****注意null的问题：typeof null 返回'object'是一个无法修复的错误

2.检测类型
	typeof
	instanceof：返回布尔类型
		语法格式：检测的数据 instanceof 所属构造函数名称

七十八 对象-创建对象
1.字面量形式 var obj={};
	获取对象的属性对应的值：
		var obj={
			age:18,
		}
		obj.age ||   obj['age']
2.构造函数形式 new         78-1
	构造函数首字母要大写
3.Object.create():创建一个新的对象，使用现有的对象来提供创建的对象的原型

七十九 对象-设置属性-删除属性
1.设置属性
	==判断对象是否有该属性
	in:属性名称 in 对象 ===>返回布尔值
	对象.hasOwnProperty:判断对象自身是否有某个属性
	**区别：in可以检测对象自身属性也可以检测原型的属性
2.删除属性
	delete 对象.属性
	**对象即使没有这个属性，也不会报错，是返回undefined

八十 对象-get-set
	get :读
	set :写 

八十一 对象-序列化对象===特别重要
	对象转换成字符串 JSON.stringify()
	字符串转换成对象 JSON.parse()

八十二 遍历对象-合并对象
遍历对象 
	1.for ... in 
		for(var k in obj){
			k==>就是属性名[键名]
			obj[key]==>就是值[键值]
		}
	2.Object.keys()、Object.values()    返回数组
合并对象：经常在面试中会问
	Object.assign(target,obj1,obj2...)   合并对象，复制目标对象

八十三 面试题-统计字符次数

八十四 面试题-解析url参数(参数：?之后的)

八十五 this指向
	1.this:指的函数运行时所在的环境
	2.历史原因：js语言设计this，是跟内存的数据结构有关系
	3.原理：函数可以在不同的环境运行执行，所以就需要一种机制，能够在函数体内获取当前函数运行环境
	4.this的设计目的：在函数体内，指向函数当前的运行环境
引擎会将函数单独保存在内存中

八十六 call-apply-bind :是所有函数都具有的方法
注意：函数也是对象，函数具有方法
	1.call(参数1，参数2，参数3...)
		参数1：调用函数时，内部this的具有值
		剩余的参数(参数2，参数3..)就是函数的参数
	2.apply(参数1,[参数值1,参数值2,参数值3])
		参数1：调用函数时，内部this的具有值
		参数2：是一个数组，其中数组每一个值代表了函数的参数
****call和apply的参数是不同的，apply的第二个参数是数组
	3.bind(参数1，参数2，参数3...)
		参数1：调用函数时，内部this的具有值
		剩余的参数(参数2，参数3..)就是函数的参数
****bind最终返回一个函数

八十七 面试题

八十八 对象模式-工厂模式

八十九 对象模式-构造函数
	构造函数：就是普通函数，只不过首字母要大写,函数内可以有this，这个this指向new出来的对象。

九十 对象模式-原型模式(prototype)
	function Fun(){
	}
	Fun.prototype={
		共享方法|共享属性
	}
	new Fun();
注意：
	1.函数拥有prototype属性|对象
	2.共享的属性和方法放在prototype中，不共享的放在构造函数中
	3.new缺点：无法共享属性和方法

九十一 函数和对象的关系
	函数有：prototype
	对象有：__proto__

九十二 new操作符具体做了什么事
	1.创建一个对象 new Object()
	2.原型赋值[指向共同一个原型对象]
		对象.__proto__=Fun.prototype
	3.改变this指向
		Fun.call(obj);

九十三 浅拷贝和深拷贝
	1.拷贝=复制
	2.浅拷贝：
		只复制一层对象，当对象的属性是引用类型时，实质上复制的其引用，    93-1
		当引用指向的值发生变化的时候，原对象的属性值也会跟着变化，互相影响。
	Object.assign()
	3.深拷贝：
		在拷贝的时候，创建新的对象，并把原对象所有的属性都深拷贝到新对象，  93-2
		原属性如果是对象，也会重新创建新的对象并拷贝到新对象属性中，这样旧对象和新对象就是相互独立，互不影响。
	1----JSON.parse()+JSON.stringify 
	2----递归

九十四 原型链-继承
1.为什么设计原型：
	继承，让对象的属性和方法实现共享
	函数prototype
	对象__proto__
2.原型链：每一个对象都有原型(__proto__)，这个原型还有属于自己的原型，最终形成了原型链。原型最顶端null。
****如果要查找对象的属性或者方法，我们先要去对象中查找，
	如果没有查找到===》要去对象的原型中查找
	如果还没有查找===》要去当前对象的原型的原型中查找
	以此类推...知道找不到，返回undefined
3.继承
	实现原型继承
	Child.prototype=new Parent();

九十五 面试题-原型相关

九十六 借用构造函数
每次生成一个对象，对象本身的属性和方法不共享。
	call,apply,bind

九十七 组合继承:原型+借用构造函数 
1.原型：
	好：共享属性和方法
	不好：无法向父构造函数传递参数
2.借用构造函数 
	好：可以向父构造函数传递参数
	不好：不可以共享属性和方法
3.组合继承：既可以传递参数，也可以实现该有的共享性


九十八 案例-无缝滚动

九十九 初谈前端性能优化
1.一个网站打开速度多少合适？
	pc:4s以内
	移动端：3s以内
2.浏览器的渲染过程
	视觉变化[js操作]-->style-->layout[布局]-->point[绘制]-->composite[合并]
3.当在浏览器输入一个url，按回车的时候，会经历什么步骤(过程-->哪有问题-->优化)
	1》通过浏览器的解释器，把文本[代码]，解析成html
	dom树 css树
	2》然后进行合并，并且渲染
4.layout 布局---->造成回流[css3动画改正回流]
	添加/删除元素
	移动/改变大小元素：offsetLeft,scrollTop,style.width
	修改浏览器大小和字体大小
5.js优化需要注意的
	原型链 

一百 debugger和try
1.错误调试：debugger形式
2.错误
	ReferenceError:非法或者不能识别的引用数值
	SyntaxError:发生语法解析错误
	TypeError:操作类型错误
3.try...catch:让错误代码不影响后续代码运行



confirm() 方法用于显示一个带有指定消息和 OK 及取消按钮的对话框







	